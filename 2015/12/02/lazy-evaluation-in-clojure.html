<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Lazy Evaluation In Clojure</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/borland.css">
    
    <link type="application/atom+xml" rel="alternate" href="/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Lazy Evaluation In Clojure</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Lazy Evaluation In Clojure" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A couple of weeks ago I had to debug a really mind-boggling (for me) problem at work and it took me the better part of three days to figure it out. A Clojure program I had created in order to crunch some data threw a stack overflow exception provided the input was large enough. When I say large enough, I mean around 150 megabytes in JSON format. So not huge, but neither negligible." />
<meta property="og:description" content="A couple of weeks ago I had to debug a really mind-boggling (for me) problem at work and it took me the better part of three days to figure it out. A Clojure program I had created in order to crunch some data threw a stack overflow exception provided the input was large enough. When I say large enough, I mean around 150 megabytes in JSON format. So not huge, but neither negligible." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-12-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Lazy Evaluation In Clojure" />
<script type="application/ld+json">
{"description":"A couple of weeks ago I had to debug a really mind-boggling (for me) problem at work and it took me the better part of three days to figure it out. A Clojure program I had created in order to crunch some data threw a stack overflow exception provided the input was large enough. When I say large enough, I mean around 150 megabytes in JSON format. So not huge, but neither negligible.","headline":"Lazy Evaluation In Clojure","dateModified":"2015-12-02T00:00:00+00:00","datePublished":"2015-12-02T00:00:00+00:00","url":"/2015/12/02/lazy-evaluation-in-clojure.html","mainEntityOfPage":{"@type":"WebPage","@id":"/2015/12/02/lazy-evaluation-in-clojure.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <nav>
  Nikos Fertakis
  
  <a href="/" >Home</a>
  
  <a href="/blog.html" >Blog</a>
  
  <a href="/about.html" >About</a>
  
</nav>

    <h1>Lazy Evaluation In Clojure</h1>

<p>
  02 Dec 2015
  
  
</p>

<p>A couple of weeks ago I had to debug a really mind-boggling (for me)
problem at work and it took me the better part of three days to figure
it out. A Clojure program I had created in order to crunch some data
threw a stack overflow exception provided the input was large enough.
When I say large enough, I mean around 150 megabytes in JSON format.
So not huge, but neither negligible.</p>

<p>Let me describe the situation. After some processing, I had a large
vector of hash maps that looked like this:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[{</span><span class="s">"ab"</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="s">"bc"</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="s">"de"</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="s">"ab"</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">]}]</span></code></pre></figure>

<p>So each hash map was essentially mapping a string to a vector which
contained two numbers. The catch is that there are duplicate strings
there and the task was to merge them into one single hash map that
would contain the sum of each number in the vectors. So the example
above would become:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="s">"ab"</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="s">"bc"</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="s">"de"</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">]}</span></code></pre></figure>

<p>“Easy enough”, I thought and proceeded to write:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">merge-hashes-naive</span><span class="w"> </span><span class="p">[</span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">merge-with</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span></code></pre></figure>

<p>Experienced Clojure developers should already be cringing with my
naivety.</p>

<p>However, the program processed all the input easily and it wasn’t until
I added the next function that things got bad. After merging all the
hash maps, I needed to drop some of them and perform calculations based
on some business rules. I decided to use a list comprehension:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">simple-list-comp</span><span class="w"> </span><span class="p">[</span><span class="n">results</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">k</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]]</span><span class="w"> </span><span class="n">results</span><span class="p">]</span><span class="w">
    </span><span class="no">:when</span><span class="w"> </span><span class="c1">;; do stuff</span></code></pre></figure>

<p>For small input, this worked fine. It wasn’t until I tried it using
the full input that the stack overflow exception was thrown. And the
stack trace was huge:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">java.lang.StackOverflowError
</span><span class="gp">     at clojure.core$</span>seq.invoke<span class="o">(</span>core.clj:133<span class="o">)</span>
<span class="gp">     at clojure.core$</span>concat<span class="nv">$fn__3955</span>.invoke<span class="o">(</span>core.clj:685<span class="o">)</span>
<span class="go">     at clojure.lang.LazySeq.sval(LazySeq.java:40)
     at clojure.lang.LazySeq.seq(LazySeq.java:49)
     at clojure.lang.RT.seq(RT.java:484)
</span><span class="gp">     at clojure.core$</span>seq.invoke<span class="o">(</span>core.clj:133<span class="o">)</span>
<span class="c">     ......</span></code></pre></figure>

<p>The first thing I thought was “I saw this somewhere recently” and
quickly remembered Stuart Sierra’s <a href="http://stuartsierra.com/2015/04/26/clojure-donts-concat">post on the concat function</a>
(I think his “<a href="http://stuartsierra.com/tag/dos-and-donts">Clojure do’s and dont’s</a>”
series is mandatory reading for Clojure programmers). He writes:</p>

<blockquote>
  <p>This is a nasty bug in production code, because it could occur far
away from its source, and the accumulated stack frames of seq prevent
us from seeing where the error originated.</p>
</blockquote>

<p>After trying a lot of things to solve it, all to no avail — the program
had much more going on than these two functions — I decided to try to
read the bottom of the (usually truncated) stack trace. Fortunately,
there is a JVM option for that:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">-XX:MaxJavaStackTraceDepth=-1</span></code></pre></figure>

<p>Long story short, the stack trace pointed to the second line of the
<code class="language-plaintext highlighter-rouge">simple-list-comp</code> function. I thought a bit about it, decided it was
random and ignored it completely.</p>

<p>A couple of days passed.</p>

<p>By then it was Friday, and this had taken me almost half a week to
solve. I could just use a larger stack, but knew that I would have
to deal with it eventually. So I thought I would take another look at
the <code class="language-plaintext highlighter-rouge">simple-list-function</code>. I removed all logic from it and just let it
pass once through the input. Stack overflow. Then, I changed the
destructuring:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="n">results</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">)</span></code></pre></figure>

<p><em>It didn’t blow up.</em> Somehow, the destructuring of the vector was where
the problem occurred (note to self: I should trust the stack traces
more). Suddenly, it all clicked: <em>The destructuring triggered the
evaluation, it was all lazy seqs until that point!</em> But of course!
The map function wraps its result in a lazy seq, meaning that nothing
gets evaluated until the result is needed.</p>

<p>What this means is that whenever the call to <code class="language-plaintext highlighter-rouge">merge-with</code> encountered
a key it had seen before, instead of calculating the result, it wrapped
the calculation inside a lazy seq and returned. For example, merging:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[{</span><span class="s">"ab"</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="s">"ab"</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">]}</span><span class="w"> </span><span class="p">{</span><span class="s">"ab"</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">]}]</span></code></pre></figure>

<p>instead of returning just:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="s">"ab"</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">]}</span></code></pre></figure>

<p>would essentially return:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="s">"ab"</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">]))}</span></code></pre></figure>

<p>where the nested maps would only get evaluated when needed, which in my
case was when destructuring the list comprehension arguments. Each
nested call would consume a bit of the stack and when the nesting
became large enough, the stack would overflow. In my case it took about
1,500 calls (so a key would exist 1,500 times in the original
collection).</p>

<p>The easiest mitigation was to replace <code class="language-plaintext highlighter-rouge">map</code> with its eager counterpart,
<code class="language-plaintext highlighter-rouge">mapv</code>:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">merge-hashes-naive</span><span class="w"> </span><span class="p">[</span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">merge-with</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span></code></pre></figure>

<p>But the real gain was finally understanding that lazy evaluation
happens all the time in Clojure. For example <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">range</code>
and <code class="language-plaintext highlighter-rouge">take</code> are all lazy.</p>

<p>I hope this will be helpful to another Clojure newbie in the future.
For more about lazy evaluation in Clojure I suggest reading <a href="http://clojure-doc.org/articles/language/laziness.html">Laziness in Clojure</a>
and chapter 3 from the excellent <a href="https://www.manning.com/books/the-joy-of-clojure-second-edition">Joy of Clojure</a>
book.</p>



  </body>
</html>
